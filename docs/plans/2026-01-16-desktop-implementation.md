# Desktop XP Shell Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a clean Next.js XP desktop shell with a first-run setup wizard, Postgres via Prisma, and admin-only invite registration.

**Architecture:** New Next.js App Router app. Setup runs on non-desktop pages, writes config to `/data/config.json`, runs Prisma migrations, and creates the first admin. Desktop renders only after auth. Modules are auto-discovered via a generated registry; optional `/data/modules.json` overrides visibility and labels.

**Tech Stack:** Next.js (App Router), NextAuth Credentials, Prisma + Postgres, Vitest, Docker Compose.

---

### Task 1: Scaffold the Next.js app

**Files:**
- Create: `package.json` (generated by `create-next-app`)
- Create: `src/app/layout.tsx`, `src/app/page.tsx` (generated)
- Create: `tsconfig.json`, `next.config.mjs`, `eslint.config.mjs` (generated)

**Step 1: Create app skeleton**

Run: `npx create-next-app@latest . --ts --app --eslint --src-dir --no-tailwind`
Expected: Next.js project created in the worktree.

**Step 2: Verify baseline**

Run: `npm run lint`
Expected: PASS

**Step 3: Commit**

```bash
git add .
git commit -m "chore: scaffold next app"
```

---

### Task 2: Add Vitest setup for unit tests

**Files:**
- Create: `vitest.config.ts`
- Create: `vitest.setup.ts`
- Modify: `package.json` (add `test` script)

**Step 1: Write minimal config**

```ts
// vitest.config.ts
import { defineConfig } from "vitest/config";
import path from "node:path";

export default defineConfig({
  test: {
    environment: "node",
    setupFiles: ["./vitest.setup.ts"],
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
```

```ts
// vitest.setup.ts
import { vi } from "vitest";

vi.stubEnv("NODE_ENV", "test");
```

**Step 2: Run test command**

Run: `npm test`
Expected: PASS with "no tests"

**Step 3: Commit**

```bash
git add vitest.config.ts vitest.setup.ts package.json
git commit -m "test: add vitest baseline"
```

---

### Task 3: Add Prisma schema and DB helpers

**Files:**
- Create: `prisma/schema.prisma`
- Create: `src/lib/db.ts`
- Create: `src/lib/db-url.ts`

**Step 1: Create schema**

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  role         Role     @default(USER)
  createdAt    DateTime @default(now())
  invites      Invite[] @relation("InvitesCreated")
}

model Invite {
  id        String   @id @default(cuid())
  codeHash  String   @unique
  createdAt DateTime @default(now())
  expiresAt DateTime
  usedAt    DateTime?
  createdBy String
  usedBy    String?
  creator   User     @relation("InvitesCreated", fields: [createdBy], references: [id])
}

enum Role {
  ADMIN
  USER
}
```

**Step 2: Add DB helper**

```ts
// src/lib/db-url.ts
import { loadRuntimeConfig } from "./runtimeConfig";

export function getDatabaseUrl() {
  loadRuntimeConfig();
  const databaseUrl = process.env.DATABASE_URL;
  if (!databaseUrl) {
    throw new Error("DATABASE_URL is required");
  }
  return databaseUrl;
}
```

```ts
// src/lib/db.ts
import { PrismaClient } from "@prisma/client";
import { PrismaPg } from "@prisma/adapter-pg";
import { Pool } from "pg";
import { getDatabaseUrl } from "./db-url";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
  pgPool: Pool | undefined;
};

const databaseUrl = getDatabaseUrl();
const pool = globalForPrisma.pgPool ?? new Pool({ connectionString: databaseUrl });
const adapter = new PrismaPg(pool);

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    adapter,
    log: process.env.NODE_ENV === "development" ? ["error", "warn"] : ["error"],
  });

if (process.env.NODE_ENV !== "production") {
  globalForPrisma.prisma = prisma;
  globalForPrisma.pgPool = pool;
}
```

**Step 3: Run Prisma generate**

Run: `npx prisma generate`
Expected: Client generated

**Step 4: Commit**

```bash
git add prisma/schema.prisma src/lib/db.ts src/lib/db-url.ts
git commit -m "feat: add prisma schema and db helpers"
```

---

### Task 4: Runtime config store + tests

**Files:**
- Create: `src/lib/runtimeConfig.ts`
- Create: `src/lib/__tests__/runtime-config.test.ts`

**Step 1: Write failing test**

```ts
import { describe, expect, it, vi } from "vitest";
import { loadRuntimeConfig, resolveConfigPath } from "../runtimeConfig";

describe("runtime config", () => {
  it("uses /data/config.json by default", () => {
    vi.stubEnv("DATA_DIR", "");
    expect(resolveConfigPath()).toBe("/data/config.json");
  });

  it("sets env vars when config exists", () => {
    vi.stubEnv("DATABASE_URL", "");
    const config = {
      databaseUrl: "postgresql://user:pass@host/db",
      nextAuthSecret: "secret1234567890abcd",
      keysEncryptionSecret: "secret1234567890abcd",
    };
    const load = loadRuntimeConfig({
      mockConfig: config,
    });
    expect(load.databaseUrl).toBe(config.databaseUrl);
    expect(process.env.DATABASE_URL).toBe(config.databaseUrl);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test -- src/lib/__tests__/runtime-config.test.ts`
Expected: FAIL with missing exports

**Step 3: Implement runtime config**

```ts
// src/lib/runtimeConfig.ts
import { readFileSync, existsSync } from "node:fs";
import { resolve } from "node:path";

export type RuntimeConfig = {
  databaseUrl: string;
  nextAuthSecret: string;
  keysEncryptionSecret: string;
};

export function resolveConfigPath() {
  const base = process.env.DATA_DIR?.trim() || "/data";
  return resolve(base, "config.json");
}

function readConfigFile(path: string): RuntimeConfig | null {
  if (!existsSync(path)) {
    return null;
  }
  const raw = readFileSync(path, "utf-8");
  return JSON.parse(raw) as RuntimeConfig;
}

export function loadRuntimeConfig(options?: { mockConfig?: RuntimeConfig | null }) {
  const config = options?.mockConfig ?? readConfigFile(resolveConfigPath());
  if (!config) {
    return null;
  }
  process.env.DATABASE_URL ||= config.databaseUrl;
  process.env.NEXTAUTH_SECRET ||= config.nextAuthSecret;
  process.env.KEYS_ENCRYPTION_SECRET ||= config.keysEncryptionSecret;
  return config;
}
```

**Step 4: Run test to verify it passes**

Run: `npm test -- src/lib/__tests__/runtime-config.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/lib/runtimeConfig.ts src/lib/__tests__/runtime-config.test.ts
git commit -m "feat: add runtime config loader"
```

---

### Task 5: Setup status helper + tests

**Files:**
- Create: `src/lib/setupStatus.ts`
- Create: `src/lib/__tests__/setup-status.test.ts`

**Step 1: Write failing test**

```ts
import { describe, expect, it, vi } from "vitest";
import { getSetupStatus } from "../setupStatus";

describe("setup status", () => {
  it("returns needsSetup when no config", async () => {
    vi.stubEnv("DATABASE_URL", "");
    expect(await getSetupStatus({ mockConfig: null })).toBe("needsSetup");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test -- src/lib/__tests__/setup-status.test.ts`
Expected: FAIL with missing exports

**Step 3: Implement helper**

```ts
// src/lib/setupStatus.ts
import { loadRuntimeConfig, RuntimeConfig } from "./runtimeConfig";

export type SetupStatus = "needsSetup" | "needsAdmin" | "ready" | "dbUnavailable";

export async function getSetupStatus(options?: { mockConfig?: RuntimeConfig | null }) {
  const config = loadRuntimeConfig(
    options?.mockConfig !== undefined ? { mockConfig: options.mockConfig } : undefined
  );
  if (!config) {
    return "needsSetup" as const;
  }
  try {
    const { prisma } = await import("./db");
    const count = await prisma.user.count();
    return count === 0 ? "needsAdmin" : "ready";
  } catch {
    return "dbUnavailable";
  }
}
```

**Step 4: Run test to verify it passes**

Run: `npm test -- src/lib/__tests__/setup-status.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/lib/setupStatus.ts src/lib/__tests__/setup-status.test.ts
git commit -m "feat: add setup status helper"
```

---

### Task 6: Setup API + pages

**Files:**
- Create: `src/app/setup/page.tsx`
- Create: `src/app/setup/admin/page.tsx`
- Create: `src/app/api/setup/status/route.ts`
- Create: `src/app/api/setup/config/route.ts`
- Create: `src/app/api/setup/admin/route.ts`
- Create: `src/lib/setupValidation.ts`
- Create: `src/lib/__tests__/setup-validation.test.ts`

**Step 1: Write failing validation test**

```ts
import { describe, expect, it } from "vitest";
import { validateSecrets, validateDatabaseUrl } from "../setupValidation";

describe("setup validation", () => {
  it("rejects short secrets", () => {
    expect(validateSecrets("short", "short").ok).toBe(false);
  });
  it("accepts postgres url", () => {
    expect(validateDatabaseUrl("postgresql://u:p@h/db").ok).toBe(true);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test -- src/lib/__tests__/setup-validation.test.ts`
Expected: FAIL with missing exports

**Step 3: Implement validation + API**

```ts
// src/lib/setupValidation.ts
export function validateSecrets(nextAuth: string, keys: string) {
  const ok = nextAuth.trim().length >= 16 && keys.trim().length >= 16;
  return ok ? { ok: true } : { ok: false, error: "Secrets must be 16+ chars" };
}

export function validateDatabaseUrl(value: string) {
  if (!/^postgres(ql)?:\/\//i.test(value)) {
    return { ok: false, error: "Only PostgreSQL URLs are supported" };
  }
  return { ok: true };
}
```

```ts
// src/app/api/setup/config/route.ts
import { NextResponse } from "next/server";
import { mkdir, writeFile } from "node:fs/promises";
import { resolveConfigPath } from "@/lib/runtimeConfig";
import { validateSecrets, validateDatabaseUrl } from "@/lib/setupValidation";

export async function POST(request: Request) {
  const body = await request.json();
  const nextAuth = String(body?.nextAuthSecret || "");
  const keys = String(body?.keysEncryptionSecret || "");
  const databaseUrl = String(body?.databaseUrl || "");
  if (!validateSecrets(nextAuth, keys).ok || !validateDatabaseUrl(databaseUrl).ok) {
    return NextResponse.json({ error: "Invalid setup data." }, { status: 400 });
  }
  const path = resolveConfigPath();
  await mkdir(path.replace("/config.json", ""), { recursive: true });
  await writeFile(
    path,
    JSON.stringify(
      {
        databaseUrl,
        nextAuthSecret: nextAuth,
        keysEncryptionSecret: keys,
      },
      null,
      2
    ),
    { mode: 0o600 }
  );
  return NextResponse.json({ ok: true });
}
```

```ts
// src/app/api/setup/status/route.ts
import { NextResponse } from "next/server";
import { getSetupStatus } from "@/lib/setupStatus";

export async function GET() {
  const status = await getSetupStatus();
  return NextResponse.json({ status });
}
```

```ts
// src/app/api/setup/admin/route.ts
import { NextResponse } from "next/server";
import { hash } from "bcryptjs";
import { prisma } from "@/lib/db";

export async function POST(request: Request) {
  const body = await request.json();
  const email = String(body?.email || "").toLowerCase().trim();
  const password = String(body?.password || "");
  if (!email || password.length < 6) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const count = await prisma.user.count();
  if (count > 0) {
    return NextResponse.json({ error: "Admin already exists" }, { status: 409 });
  }
  const passwordHash = await hash(password, 10);
  await prisma.user.create({
    data: { email, passwordHash, role: "ADMIN" },
  });
  return NextResponse.json({ ok: true });
}
```

**Step 4: Run tests**

Run: `npm test -- src/lib/__tests__/setup-validation.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/app/api/setup src/app/setup src/lib/setupValidation.ts src/lib/__tests__/setup-validation.test.ts
git commit -m "feat: add setup flow and admin creation"
```

---

### Task 7: Auth system (login + invite registration)

**Files:**
- Create: `src/lib/auth.ts`
- Create: `src/app/api/auth/[...nextauth]/route.ts`
- Create: `src/app/login/page.tsx`
- Create: `src/app/register/page.tsx`
- Create: `src/app/api/register/route.ts`
- Create: `src/lib/invites.ts`
- Create: `src/lib/__tests__/invites.test.ts`

**Step 1: Write failing invite test**

```ts
import { describe, expect, it } from "vitest";
import { isInviteExpired } from "../invites";

describe("invites", () => {
  it("expires after 12 hours", () => {
    const created = new Date("2026-01-01T00:00:00Z");
    const expires = isInviteExpired(created, 12);
    expect(expires).toBe(true);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test -- src/lib/__tests__/invites.test.ts`
Expected: FAIL with missing exports

**Step 3: Implement auth + invite helpers**

```ts
// src/lib/invites.ts
export function isInviteExpired(createdAt: Date, hours: number) {
  const expiresAt = new Date(createdAt.getTime() + hours * 60 * 60 * 1000);
  return Date.now() > expiresAt.getTime();
}
```

```ts
// src/lib/auth.ts
import type { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { compare } from "bcryptjs";
import { prisma } from "./db";
import { loadRuntimeConfig } from "./runtimeConfig";

loadRuntimeConfig();

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null;
        }
        const email = String(credentials.email).toLowerCase();
        const user = await prisma.user.findUnique({ where: { email } });
        if (!user) {
          return null;
        }
        const isValid = await compare(credentials.password, user.passwordHash);
        if (!isValid) {
          return null;
        }
        return { id: user.id, email: user.email, role: user.role };
      },
    }),
  ],
  session: { strategy: "jwt" },
  pages: { signIn: "/login" },
  callbacks: {
    async jwt({ token, user }) {
      if (user?.role) {
        token.role = user.role;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user && token.sub) {
        session.user.id = token.sub;
        session.user.role = token.role === "ADMIN" ? "ADMIN" : "USER";
      }
      return session;
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
};
```

```ts
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
```

```ts
// src/app/api/register/route.ts
import { NextResponse } from "next/server";
import { hash } from "bcryptjs";
import { prisma } from "@/lib/db";

export async function POST(request: Request) {
  const body = await request.json();
  const email = String(body?.email || "").toLowerCase().trim();
  const password = String(body?.password || "");
  const inviteCode = String(body?.inviteCode || "").trim();
  if (!email || password.length < 6 || !inviteCode) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  // TODO: validate invite code + expiration + consume.
  const passwordHash = await hash(password, 10);
  await prisma.user.create({ data: { email, passwordHash, role: "USER" } });
  return NextResponse.json({ ok: true });
}
```

**Step 4: Run test**

Run: `npm test -- src/lib/__tests__/invites.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/lib/auth.ts src/lib/invites.ts src/lib/__tests__/invites.test.ts src/app/api/auth src/app/api/register src/app/login src/app/register
git commit -m "feat: add auth and registration skeleton"
```

---

### Task 8: Invite model + admin API (12h expiry)

**Files:**
- Create: `src/app/api/invites/route.ts`
- Modify: `src/app/api/register/route.ts`
- Create: `src/lib/inviteCodes.ts`
- Create: `src/lib/__tests__/invite-codes.test.ts`

**Step 1: Write failing invite code test**

```ts
import { describe, expect, it } from "vitest";
import { hashInviteCode, verifyInviteCode } from "../inviteCodes";

describe("invite codes", () => {
  it("verifies hashed code", async () => {
    const raw = "INVITE-123";
    const hash = await hashInviteCode(raw);
    expect(await verifyInviteCode(raw, hash)).toBe(true);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test -- src/lib/__tests__/invite-codes.test.ts`
Expected: FAIL with missing exports

**Step 3: Implement helpers + API**

```ts
// src/lib/inviteCodes.ts
import { hash, compare } from "bcryptjs";

export function hashInviteCode(code: string) {
  return hash(code, 10);
}

export function verifyInviteCode(code: string, hashValue: string) {
  return compare(code, hashValue);
}
```

```ts
// src/app/api/invites/route.ts
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { hashInviteCode } from "@/lib/inviteCodes";

export async function POST() {
  const session = await getServerSession(authOptions);
  if (session?.user?.role !== "ADMIN") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const raw = `INV-${Math.random().toString(36).slice(2, 8).toUpperCase()}`;
  const codeHash = await hashInviteCode(raw);
  const expiresAt = new Date(Date.now() + 12 * 60 * 60 * 1000);
  await prisma.invite.create({
    data: { codeHash, createdBy: session.user.id, expiresAt },
  });
  return NextResponse.json({ code: raw, expiresAt });
}
```

**Step 4: Update register**

```ts
// src/app/api/register/route.ts (add invite validation)
// - find unused invite by hash match
// - reject expired or used
// - mark usedAt + usedBy
```

**Step 5: Run test**

Run: `npm test -- src/lib/__tests__/invite-codes.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add src/app/api/invites src/app/api/register src/lib/inviteCodes.ts src/lib/__tests__/invite-codes.test.ts
git commit -m "feat: add invites with 12h expiry"
```

---

### Task 9: Module registry generator

**Files:**
- Create: `scripts/generate-modules-registry.mjs`
- Create: `src/modules/registry.ts` (generated)
- Create: `src/modules/types.ts`
- Modify: `package.json` (add `predev`/`prebuild`)

**Step 1: Add module types**

```ts
// src/modules/types.ts
export type ModuleManifest = {
  id: string;
  title: string;
  subtitle?: string;
  icon?: string;
  desktopIcon?: boolean;
  startMenu?: boolean;
  defaultOpen?: boolean;
  Window: React.ComponentType;
};
```

**Step 2: Add generator**

```js
// scripts/generate-modules-registry.mjs
import { readdirSync, writeFileSync } from "node:fs";
import { join } from "node:path";

const base = join(process.cwd(), "src/modules");
const entries = readdirSync(base, { withFileTypes: true })
  .filter((dir) => dir.isDirectory())
  .map((dir) => dir.name);

const imports = entries.map((name, index) => `import mod${index} from "./${name}/module";`);
const list = entries.map((_, index) => `mod${index}`);

const output = `${imports.join("\n")}\n\nexport const modules = [${list.join(", ")}];\n`;
writeFileSync(join(base, "registry.ts"), output);
```

**Step 3: Add predev/prebuild hooks**

```json
"scripts": {
  "predev": "node scripts/generate-modules-registry.mjs",
  "prebuild": "node scripts/generate-modules-registry.mjs"
}
```

**Step 4: Commit**

```bash
git add scripts/generate-modules-registry.mjs src/modules/types.ts package.json
git commit -m "feat: add module registry generator"
```

---

### Task 10: XP Desktop shell + core modules

**Files:**
- Create: `src/components/desktop/*` (ported XP shell)
- Create: `src/modules/core/*`
- Modify: `src/app/page.tsx` (auth gate -> desktop)
- Modify: `src/app/globals.css` (XP theme)
- Create: `src/config/desktop.ts`

**Step 1: Port XP components**
- Copy `DesktopShell`, `Taskbar`, `StartMenu`, `Window`, `DesktopIcons`, `SettingsProvider`, and core apps from `eth-portfolio`.
- Remove Ethfolio-specific items and strings; brand as “Desktop”.
- Move core windows into module manifests under `src/modules/core`.

**Step 2: Desktop config**

```ts
// src/config/desktop.ts
export const desktopConfig = {
  wallpaper: "/wallpapers/windows-xp.jpg",
  sounds: {
    startup: "/sounds/win-xp/windows-xp-startup.mp3",
    shutdown: "/sounds/win-xp/windows-xp-shutdown.mp3",
    minimize: "/sounds/win-xp/windows-xp-minimize.mp3",
    restore: "/sounds/win-xp/windows-xp-restore.mp3",
  },
};
```

**Step 3: Desktop render only after auth**
- `src/app/page.tsx` should redirect unauthenticated users to `/login`.
- Desktop uses `modules` registry to build windows, icons, and start menu.

**Step 4: Commit**

```bash
git add src/components/desktop src/modules src/config/desktop.ts src/app/page.tsx src/app/globals.css public
git commit -m "feat: add xp desktop shell and core modules"
```

---

### Task 11: Auth gating + setup routing

**Files:**
- Create: `middleware.ts`
- Modify: `src/app/layout.tsx`

**Step 1: Add middleware**

```ts
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { getSetupStatus } from "@/lib/setupStatus";
import { getToken } from "next-auth/jwt";

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  if (pathname.startsWith("/api")) {
    return NextResponse.next();
  }
  const status = await getSetupStatus();
  if (status === "needsSetup" && !pathname.startsWith("/setup")) {
    return NextResponse.redirect(new URL("/setup", request.url));
  }
  if (status === "needsAdmin" && !pathname.startsWith("/setup/admin")) {
    return NextResponse.redirect(new URL("/setup/admin", request.url));
  }
  const token = await getToken({ req: request });
  const isAuthRoute = pathname.startsWith("/login") || pathname.startsWith("/register");
  if (!token && !isAuthRoute && !pathname.startsWith("/setup")) {
    return NextResponse.redirect(new URL("/login", request.url));
  }
  return NextResponse.next();
}
```

**Step 2: Commit**

```bash
git add middleware.ts src/app/layout.tsx
git commit -m "feat: add setup and auth gating"
```

---

### Task 12: Docker + compose

**Files:**
- Create: `Dockerfile`
- Create: `docker-compose.yml`
- Create: `.dockerignore`

**Step 1: Add Dockerfile**

```Dockerfile
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci

FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
COPY --from=builder /app ./
EXPOSE 3000
CMD ["npm", "run", "start"]
```

**Step 2: Add compose**

```yaml
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: desktop
      POSTGRES_PASSWORD: desktop
      POSTGRES_DB: desktop
    volumes:
      - db_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  web:
    build: .
    ports:
      - "3000:3000"
    volumes:
      - ./data:/data
    depends_on:
      - db

volumes:
  db_data:
```

**Step 3: Verify**

Run: `docker compose config`
Expected: valid config

**Step 4: Commit**

```bash
git add Dockerfile docker-compose.yml .dockerignore
git commit -m "feat: add docker setup"
```

---

### Task 13: Documentation

**Files:**
- Create: `README.md`

**Step 1: Write README**
- Include setup flow, docker usage, config file location, invite rules, and module structure.

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: add setup and module docs"
```
